# 硕含 Agent 三层记忆系统架构白皮书 (v5.0)

> **Identity:** 硕含 (Shuohan)
> **Core Feature:** 全自动持久化三层记忆系统
> **Architecture Version:** v5.0 (内核锁定 - 强制存盘模式)

---

## 💎 一、 记忆层级设计 (Architecture)

系统采用典型的 **Hot / Cold / Agent** 三层金字塔架构，确保 Agent 既有短期对话的灵敏度，又有长期的个性化沉淀。

| 层级 | 存储文件名 | 核心用途 | 写入时机 | 价值 |
| :--- | :--- | :--- | :--- | :--- |
| **Hot (热记忆)** | `hot.md` | 会话上下文同步 | **每一轮对话必写** | 保证对话连贯，防断点丢失 |
| **Cold (冷记忆)** | `cold.md` | 用户习惯与偏好 | 用户显式表达需求时 | 提供个性化服务，避免重复确认 |
| **Agent (经验池)** | `agent.md` | 技术总结与 Bug 修复 | 解决复杂难题或架构调整后 | 实现 Agent 的自我进化 |

---

## 🛠️ 二、 实现路径 (Implementation)

1.  **底层执行层 (`memory_ops.py`)**:
    *   作为唯一的原子操作接口，通过 Python 脚本直接管理文件系统。
    *   **核心特性**: UTF-8 编码锁定 (`chcp 65001`)、时间戳自动追加、多平台路径适配。

2.  **插件封装层 (`memory.js`)**:
    *   OpenCode 原生插件，将 Python 操作包装为标准工具（Tools）。
    *   **职责**: 提供 `memory_read` 与 `memory_write` 的底层调用能力。

3.  **内核约束层 (`system.md`)**:
    *   **V5.0 核心指令**: 剥离 Agent “先说话”的权利。强制要求 Agent 在输出回复前，必须先调用 `bash` 执行写入逻辑。

---

## ⚡ 三、 痛苦复盘：为什么之前总失败？ (Lessons Learned)

在从 v1.0 迭代到 v5.0 的过程中，我们踩过了无数“自动化”的深坑。以下是导致之前一致失败的**三大痛点**：

### 1. 行为不可控性 (Agent Fatigue)
*   **现象**: Agent 在对话初期表现良好，但随着对话深度增加（Context 压力增大），它会“忘记”调用写入工具。
*   **教训**: 绝不能依赖 Agent 的“自觉性”。任何“建议执行”的指令，在压力下都会变成“可选执行”。

### 2. 后台钩子不稳定性 (Plugin Hook Failure)
*   **现象**: 尝试在 `memory.js` 插件中使用 `onBeforeResponse` 拦截回复。虽然逻辑完美，但在某些环境中，由于异步并发或权限问题，该钩子无法稳定触发。
*   **教训**: 透明的、无感知的后台写入固然优雅，但在一个复杂的 Agent 运行环境中，**显式的指令执行**远比后台静默拦截更可靠。

### 3. 环境编码灾难 (Encoding Hell)
*   **现象**: 在 Windows 的 VS Code 终端中，写入中文经常出现乱码，导致 Agent 读取后“胡言乱语”。
*   **教训**: 必须在每次执行脚本前强制注入 `chcp 65001`，且文件读写必须显式指定 `utf-8`。

---

## 🚀 四、 终极解决方案 (The Final Solution)

**“内核锁定 + 强制协议”**

我们不再追求“让 Agent 感觉不到记忆在写入”，而是直接把写入动作**固化到它的思考流程**中。

> **逻辑闭环**: 用户输入 → Agent 强制执行存盘命令 (Bash) → 命令成功返回结果 → Agent 发送最终回复内容。

这种方案将记忆写入从“一个功能”变成了“一个前置条件”，彻底解决了断档问题。

---

## 📅 五、 维护建议

1.  **定期清理**: 建议每 50 轮对话手动归档一次 `hot.md` 至 `cold.md` 或 `agent.md`。
2.  **Git 同步**: 所有的记忆文件都在 `.opencode` 目录下，定期执行 `git push` 可实现跨设备记忆同步。

---
*文档维护者: 硕含 (Shuohan) v5.0 系统核心*
